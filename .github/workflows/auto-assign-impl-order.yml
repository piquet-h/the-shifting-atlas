name: Auto Assign Implementation Order

on:
    issues:
        types: [opened, edited, labeled, unlabeled, milestoned, demilestoned, reopened]
    workflow_dispatch:
        inputs:
            issue_number:
                description: Specific issue number to analyze
                # Manual dispatch requires explicit issue number.
                required: true
                type: string
            force_resequence:
                description: Force resequence even if current position seems acceptable
                required: false
                type: boolean

permissions:
    contents: write
    issues: write

concurrency:
    group: auto-impl-order-${{ github.repository }}
    cancel-in-progress: false

jobs:
    assign:
        name: Analyze & Assign Implementation Order
        runs-on: ubuntu-latest
        timeout-minutes: 8
        steps:
            - name: Checkout
              uses: actions/checkout@v4
              with:
                  # Need full history for safe rebase when concurrent automation commits occur
                  fetch-depth: 0

            - name: Setup Node
              uses: actions/setup-node@v4
              with:
                  node-version: 20
                  cache: npm

            - name: Install Dependencies
              run: npm ci

            - name: Resolve Issue Number
              id: issue
              run: |
                  # Resolve issue number based on trigger type.
                  # For manual dispatch, the input is now required (enforced above); still guard just in case.
                  if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
                    if [ -z "${{ github.event.inputs.issue_number }}" ]; then
                      echo "::error::Manual dispatch requires 'issue_number' input." >&2
                      exit 1
                    fi
                    echo "number=${{ github.event.inputs.issue_number }}" >> "$GITHUB_OUTPUT"
                  else
                    # Issue-triggered events should always have github.event.issue.number
                    if [ -z "${{ github.event.issue.number }}" ]; then
                      echo "::error::Could not resolve issue number from event payload." >&2
                      exit 1
                    fi
                    echo "number=${{ github.event.issue.number }}" >> "$GITHUB_OUTPUT"
                  fi

            - name: Fetch Issue Details
              id: fetch
              env:
                  GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
              run: |
                  set -euo pipefail
                  if [ -z "${{ steps.issue.outputs.number }}" ]; then
                    echo "::error::Issue number not set; aborting fetch." >&2
                    exit 1
                  fi
                  gh api repos/${{ github.repository }}/issues/${{ steps.issue.outputs.number }} > issue.json
                  jq -r '.body // ""' issue.json > issue_body.txt
                  echo "state=$(jq -r .state issue.json)" >> "$GITHUB_OUTPUT"
                  echo "title=$(jq -r .title issue.json)" >> "$GITHUB_OUTPUT"
                  echo "labels=$(jq -r '[.labels[].name] | join(",")' issue.json)" >> "$GITHUB_OUTPUT"
                  echo "milestone=$(jq -r '.milestone.title // ""' issue.json)" >> "$GITHUB_OUTPUT"

            - name: Skip Closed Issues
              if: steps.fetch.outputs.state == 'closed'
              run: echo "Issue closed; skipping workflow." && exit 0

            - name: Detect Existing Order
              id: existing
              run: |
                  set -euo pipefail
                  issue=${{ steps.issue.outputs.number }}
                  if [ -f roadmap/implementation-order.json ] && grep -q "\"issue\": ${issue}," roadmap/implementation-order.json; then
                    echo "has=true" >> "$GITHUB_OUTPUT"
                    current=$(jq -r ".items[] | select(.issue == ${issue}) | .order" roadmap/implementation-order.json)
                    echo "order=${current}" >> "$GITHUB_OUTPUT"
                  else
                    echo "has=false" >> "$GITHUB_OUTPUT"
                    echo "order=0" >> "$GITHUB_OUTPUT"
                  fi

            - name: Analyze Issue Priority
              id: analysis
              run: |
                  set -euo pipefail
                  FORCE=${{ github.event.inputs.force_resequence || 'false' }}
                  node scripts/analyze-issue-priority.mjs \
                    --issue-number "${{ steps.issue.outputs.number }}" \
                    --title "${{ steps.fetch.outputs.title }}" \
                    --description-file issue_body.txt \
                    --labels "${{ steps.fetch.outputs.labels }}" \
                    --milestone "${{ steps.fetch.outputs.milestone }}" \
                    --has-existing-order "${{ steps.existing.outputs.has }}" \
                    --existing-order "${{ steps.existing.outputs.order }}" \
                    --force-resequence "${FORCE}" > analysis.json
                  echo "recommended=$(jq -r .recommendedOrder analysis.json)" >> "$GITHUB_OUTPUT"
                  echo "resequence=$(jq -r .requiresResequence analysis.json)" >> "$GITHUB_OUTPUT"
                  echo "confidence=$(jq -r .confidence analysis.json)" >> "$GITHUB_OUTPUT"
                  echo "action=$(jq -r .action analysis.json)" >> "$GITHUB_OUTPUT"
                  jq -r .rationale analysis.json > rationale.txt
                  echo "Priority score: $(jq -r .priorityScore analysis.json)"

            - name: Apply Ordering
              if: steps.analysis.outputs.action != 'skip'
              run: |
                  node scripts/apply-impl-order-assignment.mjs \
                    --issue-number "${{ steps.issue.outputs.number }}" \
                    --title "${{ steps.fetch.outputs.title }}" \
                    --recommended-order "${{ steps.analysis.outputs.recommended }}" \
                    --requires-resequence "${{ steps.analysis.outputs.resequence }}" \
                    --action "${{ steps.analysis.outputs.action }}"

            - name: Select Token
              id: token
              run: |
                  if [ -n "${{ secrets.PROJECTS_TOKEN }}" ]; then
                    echo "value=${{ secrets.PROJECTS_TOKEN }}" >> "$GITHUB_OUTPUT"
                  else
                    echo "value=${{ secrets.GITHUB_TOKEN }}" >> "$GITHUB_OUTPUT"
                  fi

            - name: Sync & Regenerate Docs
              if: steps.analysis.outputs.action != 'skip'
              env:
                  GITHUB_TOKEN: ${{ steps.token.outputs.value }}
                  ALLOW_MISSING_PROJECT: 'true'
              run: node scripts/sync-implementation-order.mjs apply || echo "Sync degraded"

            - name: Commit & Push Changes
              if: steps.analysis.outputs.action != 'skip'
              run: |
                  set -euo pipefail
                  if git diff --quiet roadmap/implementation-order.json docs/roadmap.md; then
                    echo "No file changes to commit"
                    exit 0
                  fi

                  git config user.name 'github-actions[bot]'
                  git config user.email 'github-actions[bot]@users.noreply.github.com'
                  git add roadmap/implementation-order.json docs/roadmap.md
                  git commit -m "chore: impl-order: existing=${{ steps.existing.outputs.has }} -> ${{ steps.analysis.outputs.recommended }} (#${{ steps.issue.outputs.number }})" || echo "Nothing to commit after add (race)"

                  # Retry push with rebase to handle concurrent workflow runs updating main.
                  success=0
                  for attempt in 1 2 3; do
                    echo "Attempt ${attempt}: syncing with latest origin/main before push"
                    # Always fetch first (already full history due to fetch-depth:0)
                    git fetch origin main
                    # Rebase; if it fails (conflict), fall back to an auto-merge (keeping both changes) and continue.
                    if ! git rebase origin/main; then
                      echo "Rebase failed (likely conflict). Attempting merge fast-forward or regular merge." >&2
                      git rebase --abort || true
                      git merge --no-edit origin/main || true
                    fi
                    if git push; then
                      echo "Push succeeded on attempt ${attempt}."
                      success=1
                      break
                    else
                      echo "Push failed on attempt ${attempt}. Will retry after backoff." >&2
                      sleep $((attempt * 2))
                    fi
                  done

                  if [ "$success" -ne 1 ]; then
                    echo "::warning::Failed to push after 3 attempts (likely high contention). Consider re-running the workflow." >&2
                    # Do not fail the workflow; the ordering change can be retried safely.
                  fi

            - name: Comment (Non-High Confidence)
              if: steps.analysis.outputs.action != 'skip' && steps.analysis.outputs.confidence != 'high'
              env:
                  GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
              run: |
                  cat > comment.md <<'EOF'
                  **Implementation Order Auto-Assignment**

                  Action: ${{ steps.analysis.outputs.action }}
                  Recommended Order: `${{ steps.analysis.outputs.recommended }}`
                  Confidence: `${{ steps.analysis.outputs.confidence }}`

                  Rationale:

                  $(cat rationale.txt)

                  If this looks off, adjust `roadmap/implementation-order.json` manually and re-run the workflow.
                  EOF
                  gh issue comment ${{ steps.issue.outputs.number }} --body-file comment.md || echo "Comment failed"

            - name: Cleanup
              if: always()
              run: rm -f issue.json issue_body.txt analysis.json rationale.txt comment.md || true
