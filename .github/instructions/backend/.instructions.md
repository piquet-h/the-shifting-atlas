# Backend Module – Copilot Instructions (Azure Functions v4)

## 📜 Purpose

These instructions tell GitHub Copilot exactly how to structure and implement backend logic for our MMO text adventure.  
They apply to all code in `/backend` and are **always loaded** when editing here.

---

## 🏛 Architecture Context

- **Runtime:** Azure Functions Runtime v4 (Node.js LTS: 22.x / 20.x preferred; 18.x still supported but phase-out planned). Pin Node version via `"engines"` in `package.json`.
- **Programming Model:** Node.js Azure Functions v4 (code-first). We DO NOT use legacy `function.json` authoring except for `host.json` / global settings. Triggers & bindings are declared in code via `@azure/functions` APIs.
- **Package:** Always pin `@azure/functions` to a known minor (e.g. `^4.x` but avoid broad `*`).
- **Plan:** Consumption Tier (scale-to-zero). If cold start latency for player actions becomes material, revisit Premium (pre-warmed instances) for HTTP path only.
- **Triggers:**
    - HTTP → Player actions (must stay low-latency, stateless, idempotent)
    - Service Bus Queue → World / NPC / economy events (asynchronous progression)
- **Messaging:** Azure Service Bus (Basic Tier) – queue names in `kebab-case`.
- **Data:** Azure Cosmos DB (Gremlin API) – graph persistence for rooms, NPCs, players, events.
- **Monitoring:** Application Insights (structured logs, dependency + custom events).
- **Deployment Packaging:** Run-from-package (zip) to minimize cold start + ensure atomic deploys.

---

## 🧩 Folder & Function Structure

We adopt the v4 code-first model (no per-function `function.json`). Each function is registered in a central (or feature-grouped) module that exports side-effect registrations using the `app` object from `@azure/functions`.

Recommended layout (excerpt):

```
backend/
  host.json
  package.json
  src/
    functions/
      http/
        movePlayer.js
        attackNpc.js
      queues/
        processWorldTick.js
        npcBehaviorStep.js
    shared/
      cosmosClient.js
      serviceBusClient.js
      validation.js
      constants.js
```

Conventions:

1. One file = one function registration (keep bodies small; orchestrate via messages not branching complexity).
2. File names: `camelCaseVerbNoun.js` (HTTP) / `snake_case` avoided. Export nothing; rely on side-effect registration calls.
3. Group by trigger type (e.g., `http/`, `queues/`) for discoverability.
4. Shared resource clients (Cosmos, Service Bus) are created once in `shared/` at module load (Node global scope) and imported—never per invocation.
5. Avoid circular deps by keeping `shared` free of function-specific logic.

Example (HTTP) function (simplified):

```js
// src/functions/http/movePlayer.js
import { app, HttpRequest, HttpResponseInit } from '@azure/functions';
import { getPlayerById, movePlayer } from '../../shared/player.js';
import { withJsonError } from '../../shared/http.js';

app.http('HttpMovePlayer', {
  methods: ['POST'],
  authLevel: 'Function', // Revisit for auth integration / tokens (recommend Microsoft Entra External Identities / OIDC for production)
  route: 'player/{playerId}/move',
  handler: withJsonError(async (request, context) => {
    const { playerId } = request.params;
    const body = await request.json();
    const direction = body?.direction;
    // validation & traversal logic (see traversal module rules)
    const player = await getPlayerById(playerId);
    const result = await movePlayer(player, direction);
    return { status: 200, jsonBody: { success: true, result } } satisfies HttpResponseInit;
  })
});
```

Example (Queue) function (Service Bus):

```js
// src/functions/queues/processWorldTick.js
import {app} from '@azure/functions'
import {processWorldTick} from '../../shared/worldTick.js'

app.serviceBusQueue('QueueProcessWorldTick', {
    queueName: 'world-tick',
    connection: 'SERVICEBUS_CONNECTION',
    handler: async (message, context) => {
        await processWorldTick(message, context)
    }
})
```

Migration: All new functions MUST use this pattern. Legacy `function.json` definitions are prohibited. If any remain during migration, remove them once their code-first equivalents register successfully (runtime ignores v3 style after v4 registrations begin).

---

## 🖋 Coding Conventions

- **ES modules** (`import` / `export`) for all code.
- **Async/await** for all I/O.
- **Function registration names:** Prefix with trigger type (`Http`, `Queue`) and VerbNoun (e.g., `HttpMovePlayer`).
- **Source file names:** lower camelCase descriptive verbs (`movePlayer.js`, `processWorldTick.js`).
- **Cosmos DB:**
    - Use Gremlin queries for graph traversal.
    - Collections: `Rooms`, `NPCs`, `Players`, `Events`.
    - All IDs are GUIDs; relationships stored as edges.
- **Service Bus:**
    - Queue names in `kebab-case`.
    - Message envelope JSON MUST include: `id` (GUID), `type` (string), `timestamp` (UTC ISO8601), `payload` (object), optional: `correlationId`, `replayProtectionKey`.
- **Error handling:**
    - Log errors to Application Insights.
    - Return HTTP 400/500 with JSON error object for HTTP Functions.
    - Dead-letter failed queue messages after retries.
- **Clients:** Instantiate Cosmos + Service Bus clients once (module top-level) and reuse.
- **Stateless:** No in-memory cross-invocation state; pass via messages or persist.
- **Idempotency:** Queue handlers must safely handle duplicate deliveries (use `replayProtectionKey` or message `id`).
- **Size Budget:** Keep message payloads < 48 KB to retain headroom under SB max (256 KB) for future metadata.

### JSON Error Format (HTTP)

```json
{"error": {"code": "BadRequest", "message": "Direction is invalid"}}
```

Wrap with helper `withJsonError` to standardize logging + structure.

---

## 🌍 MMO-Specific Backend Rules

- **Player actions**:
    - Always validate player session/auth before processing.
    - Recommended provider: Microsoft Entra External Identities (OIDC). Validate ID tokens server-side and map Entra `sub` or custom claims to internal player GUIDs.
    - Fetch current room and state from Cosmos DB before applying changes.
    - May enqueue follow-up events (e.g., NPC reaction).
- **World logic**:
    - Triggered only by queue messages.
    - Update world state in Cosmos DB, then enqueue next scheduled event if needed.
    - Never block on long-running tasks — split into multiple queued events.
- **Traversal**:
    - Use semantic exits (`north`, `south`, `up`, `down`) from room edges.
    - Validate exit existence before moving player.
- **NPC behaviour**:
    - State machine stored in NPC vertex properties.
    - Patrols, interactions, and AI ticks are queue-driven.
- **Economy / Timers**:
    - Slice large world ticks into atomic, time-bounded queue messages (< 2s execution target) to reduce cold start penalty impact on backlog throughput.
- **Event Chaining**:
    - Prefer explicit next-event scheduling over loops; each event decides if/when to enqueue its successor.

---

## 🧠 Copilot Usage Guidelines

- When adding a new Function (v4 code-first):

1.  Create file under `src/functions/{http|queues}/` with clear name.
2.  Import `app` from `@azure/functions` and register trigger inline.
3.  Use shared utilities; never duplicate validation / clients.
4.  Keep handler small; offload complex logic to `shared/` modules.
5.  Include concise JSDoc + link to relevant design doc section (`/docs/modules/*.md`).

- Inline relevant excerpts from `/docs/modules/*.md` into comments before writing complex logic.
- Keep Functions small — orchestrate via queues rather than large monoliths.

### Common Snippets

Reusable patterns should live in `shared/`:

- `withJsonError(handler)` – unified error surface.
- `withAuth(handler)` – player auth/session validation (future integration point).
- `enqueue(type, payload, options)` – Service Bus message builder enforcing envelope contract.

Document new helpers in `shared/README.md` (create if missing).

## ⚙️ Configuration & host.json

`host.json` (schema v2) governs global runtime + binding behavior. Keep minimal:

```jsonc
{
    "version": "2.0",
    "extensionBundle": {
        "id": "Microsoft.Azure.Functions.ExtensionBundle",
        "version": "[4.*, 5.0.0)"
    },
    "logging": {
        "applicationInsights": {
            "samplingSettings": {
                "isEnabled": true,
                "maxTelemetryItemsPerSecond": 20
            }
        }
    },
    "concurrency": {
        // Tune cautiously; start default. Example future knobs:
        // "dynamicConcurrencyEnabled": true
    },
    "serviceBus": {
        // Add batching/lock renewal settings here when needed.
    }
}
```

Environment / `local.settings.json` keys (never commit secrets):

- `SERVICEBUS_CONNECTION`
- `COSMOS_ENDPOINT`
- `COSMOS_KEY`
- `APPINSIGHTS_CONNECTION_STRING`
- `WEBSITE_RUN_FROM_PACKAGE` (set during deploy)

Optional scaling tweak (advanced): `FUNCTIONS_WORKER_PROCESS_COUNT` (rarely > 1 for Node due to single-thread event loop; prefer horizontal scale).

## 🚀 Performance & Cold Start

Principles:

1. Keep dependency tree lean (avoid large unused packages).
2. Reuse clients (Cosmos, Service Bus) – single instance prevents connection churn.
3. Target sub‑100ms handler CPU work for HTTP; push heavy tasks to queue chain.
4. Run-from-package deploys to shrink startup I/O.
5. If P95 HTTP latency dominated by cold starts → evaluate Premium (pre-warmed) or synthetic warmup ping.

Anti-patterns:

- Creating a new `GremlinClient` or `ServiceBusClient` per invocation.
- Large synchronous JSON transformations before I/O starts.
- Long-running loops instead of event chaining.

## 🛡 Reliability & Idempotency

- Use message `id` / `replayProtectionKey` to ignore duplicates (persist processed IDs short-term if necessary).
- Let Service Bus retry transient failures; only throw after defensive validation.
- Dead-letter after configured max deliveries (monitor dead-letter queue; treat as incident if >0 sustained).
- Validate all external input; never trust client-sent room IDs without verifying existence.

## 🔐 Security & Secrets

- Do not log secrets or PII.
- Centralize secret access in shared config module.
- Plan migration to Managed Identity for Cosmos once available in environment (documented future task).
- Separate future privileged admin functions into another Function App if required (least privilege blast radius).

## 🧪 Testing & Local Dev

- Unit test pure logic in `shared/` (no runtime dependency) – place under `tests/` mirroring path.
- For trigger tests: thin wrappers → mock context + request/message objects.
- Local run: `func start` (ensure Azurite/Service Bus connection or use real SB during early phase).
- Consider contract tests for message envelope structure.

## 🔄 Migration Notes

We are already on code-first v4. Any legacy artifacts (`function.json` beside function files) must be removed. If scaffolding tools generate them, delete and rewrite using `app.<trigger>()` registration.

## 🔗 Reference Links (Curated)

- Node.js v4 programming model: https://learn.microsoft.com/azure/azure-functions/functions-reference-node
- Performance & reliability: https://learn.microsoft.com/azure/azure-functions/performance-reliability
- Best practices overview: https://learn.microsoft.com/azure/azure-functions/functions-best-practices
- Managing connections: https://learn.microsoft.com/azure/azure-functions/manage-connections
- host.json reference: https://learn.microsoft.com/azure/azure-functions/functions-host-json
- Service Bus trigger: https://learn.microsoft.com/azure/azure-functions/functions-bindings-service-bus

---

## 🔄 Maintenance

- Update this file if backend architecture, conventions, or MMO rules change.
- Keep `/shared` utilities DRY and documented.
- Ensure queue names and Cosmos DB schema match `/docs/modules/` specs.

Additions pending future phases (do NOT implement until prioritized):

- Managed Identity secret removal.
- Premium plan evaluation metrics definition.
- Synthetic warmup strategy for peak windows.

---
